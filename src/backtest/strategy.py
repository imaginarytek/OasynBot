"""
Strategy base class and implementations for backtesting.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Optional
from datetime import datetime


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    timestamp: datetime
    symbol: str
    side: str  # 'buy', 'sell', or 'hold'
    confidence: float
    reason: str


class Strategy(ABC):
    """
    Abstract base class for trading strategies.
    
    Subclasses implement on_candle to generate trading signals
    based on price data and optional sentiment analysis.
    """
    
    def __init__(self, config: dict = None):
        self.config = config or {}
        self.name = self.__class__.__name__
    
    @abstractmethod
    def on_candle(
        self, 
        candle: dict, 
        sentiment: Optional[dict] = None
    ) -> Optional[Signal]:
        """
        Process a price candle and optionally sentiment data.
        
        Args:
            candle: dict with keys: timestamp, symbol, open, high, low, close, volume
            sentiment: optional dict with keys: score, confidence, label
            
        Returns:
            Signal if a trade should be made, None otherwise
        """
        pass
    
    def reset(self):
        """Reset strategy state for a new backtest run."""
        pass


class SentimentStrategy(Strategy):
    """
    Strategy that trades based on sentiment signals.
    
    - Buy when sentiment is positive with high confidence
    - Sell when sentiment is negative with high confidence
    - Hold otherwise
    """
    
    def __init__(self, config: dict = None):
        super().__init__(config)
        self.confidence_threshold = self.config.get("confidence_threshold", 0.85)
        self.last_signal = None
    
    def on_candle(
        self, 
        candle: dict, 
        sentiment: Optional[dict] = None
    ) -> Optional[Signal]:
        """Generate signal based on sentiment analysis."""
        
        # No sentiment data = no signal
        if sentiment is None:
            return None
            
        confidence = sentiment.get('confidence', 0)
        label = sentiment.get('label', 'neutral')
        score = sentiment.get('score', 0)
        
        # Check confidence threshold
        if confidence < self.confidence_threshold:
            return None
        
        # Determine side
        if label == 'positive' and score > 0:
            side = 'buy'
        elif label == 'negative' and score < 0:
            side = 'sell'
        else:
            return None
        
        # Avoid duplicate signals
        if self.last_signal == side:
            return None
            
        self.last_signal = side
        
        return Signal(
            timestamp=candle['timestamp'],
            symbol=candle['symbol'],
            side=side,
            confidence=confidence,
            reason=f"Sentiment: {label} ({score:.2f})"
        )
    
    def reset(self):
        """Reset for new backtest."""
        self.last_signal = None


class MomentumStrategy(Strategy):
    """
    Simple momentum strategy based on price changes.
    
    - Buy when price increased over lookback period
    - Sell when price decreased over lookback period
    """
    
    def __init__(self, config: dict = None):
        super().__init__(config)
        self.lookback = self.config.get("lookback", 5)
        self.threshold_pct = self.config.get("threshold_pct", 0.02)
        self.price_history = []
        self.last_signal = None
    
    def on_candle(
        self, 
        candle: dict, 
        sentiment: Optional[dict] = None
    ) -> Optional[Signal]:
        """Generate signal based on price momentum."""
        
        self.price_history.append(candle['close'])
        
        # Need enough history
        if len(self.price_history) < self.lookback:
            return None
        
        # Keep only lookback period
        if len(self.price_history) > self.lookback:
            self.price_history = self.price_history[-self.lookback:]
        
        # Calculate momentum
        start_price = self.price_history[0]
        current_price = self.price_history[-1]
        change_pct = (current_price - start_price) / start_price
        
        # Determine side
        side = None
        if change_pct > self.threshold_pct:
            side = 'buy'
        elif change_pct < -self.threshold_pct:
            side = 'sell'
        else:
            return None
        
        # Avoid duplicate signals
        if self.last_signal == side:
            return None
            
        self.last_signal = side
        
        return Signal(
            timestamp=candle['timestamp'],
            symbol=candle['symbol'],
            side=side,
            confidence=min(abs(change_pct) * 10, 1.0),
            reason=f"Momentum: {change_pct*100:.1f}% over {self.lookback} periods"
        )
    
    def reset(self):
        """Reset for new backtest."""
        self.price_history = []
        self.last_signal = None
